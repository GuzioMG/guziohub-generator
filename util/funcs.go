package util

import (
	"errors"
	"fmt"
	"math"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func DeepOpen(name string, flag int, perm os.FileMode) (*os.File, error) {
	if err := os.MkdirAll(filepath.Dir(name), perm); err != nil {
		return nil, err
	}
	return os.OpenFile(name, flag, perm)
}

/* path is only for error messages, to help the user identify where the metadata extraction was attempted - so it can be invalid (eg. something like "<internal>" or "<unknown>") if extracting from an "anonymous" source (e.g., a string) */
func ExtractMetadata(line string, path string) (*DocumentData, error) {
	regex, err := regexp.Compile(`(.*?)<html flavor="ghtml" lang="([a-z]{2})" canonical="(.+)" title="(.+)" header="(.+)" description="(.+)">(.*?)`)
	if err != nil {
		return nil, err
	}

	if match := regex.FindStringSubmatch(line); len(match) != 8 {
		return nil, errors.New("file \"" + path + "\" does not appear to be a valid HTML file, of G-HTML flavour (missing, mis(s)-attributed, or invalid opening <html> tag - found \"" + line + "\" instead)")
	} else {
		var err error = nil
		if match[1] != "" || match[7] != "" {
			err = errors.New("file \"" + path + "\" does not appear to be a valid HTML file, of G-HTML flavour (unexpected content before or after opening <html> tag: \"" + line + "\")")
		}
		return &DocumentData{
			Lang:        match[2],
			Canonical:   match[3],
			Title:       match[4],
			Header:      match[5],
			Description: match[6],
		}, err
	}
}

/* path is only for error messages, to help the user identify where the metadata extraction was attempted - so it can be invalid (eg. something like "<internal>" or "<unknown>") if extracting from an "anonymous" source (e.g., a string) */
func ProcessLine(line string, indentation string, path string, lineNum int) (*LineData, error) {

	//Compiling RegEx
	tagFinder, err := regexp.Compile(`<(\S+?) (\S+?)="(.*?)">|</(\S+?)>`)
	if err != nil {
		return nil, err
	}
	envFinder, err := regexp.Compile(`%(\S+?)%`)
	if err != nil {
		return nil, err
	}
	escFinder, err := regexp.Compile(`&(\S+?);`)
	if err != nil {
		return nil, err
	}

	//Counting typed characters and parsing env-vars
	returnedLine := line
	for _, v := range envFinder.FindAllStringSubmatch(line, -1) {
		if val, exists := os.LookupEnv(v[1]); !exists {
			return nil, errors.New("environment variable \"" + v[1] + "\" not set (while processing " + path + " at line #" + fmt.Sprint(lineNum) + " - contents: \"" + line + "\")")
		} else {
			returnedLine = strings.ReplaceAll(returnedLine, v[0], val)
		}
	}
	typedLine := escFinder.ReplaceAllString(tagFinder.ReplaceAllString(returnedLine, ""), "#")
	typedCharCount := strings.Count(typedLine, "") - 1

	//Processing content
	realNum := lineNum - 2
	prefix := "\n" + indentation + "<br><p class=\"termtxt-default\">&nbsp;$&nbsp;</p><p class=\"termtxt-default typing-animator\">"
	suffix := "</p><p class=\"termtxt-default typing-animator\">_</p>"
	if realNum == 1 {
		prefix = strings.ReplaceAll(prefix, "<br>", "")
	} else {
		prefix = strings.ReplaceAll(prefix, "&nbsp;$", "")
	}
	returnedLine = prefix + returnedLine + suffix

	//Readability guard
	var errNonFatal error = nil
	if typedCharCount > 54 {
		errNonFatal = errors.New("line of length " + fmt.Sprint(typedCharCount) + " is too long to be readable on mobile - over 54 typed characters (while processing " + path + " at line #" + fmt.Sprint(lineNum) + " - contents: \"" + line + "\")")
	}

	return &LineData{
		TypedLength:              typedCharCount,
		BytesLength:              len([]byte(returnedLine)),
		ProcessedContent:         returnedLine,
		RealNum:                  realNum,
		WordCount:                len(strings.Split(typedLine, " ")),
		TypedLengthWithoutSpaces: strings.Count(strings.ReplaceAll(typedLine, " ", ""), "") - 1,
	}, errNonFatal
}

func BuildCSSLine(line LineData, cumulativeSeconds *int, charactersPerSecond float64, contentLength int, lastLine int, shallowerIndent string, deeperIndent string) string {

	/*
		.typing-animator:nth-child(<2+(4*(n-1)))>) {
			animation: type <t> steps(<c>) <d+l> 1 normal forwards;
		}

		.typing-animator:nth-child(<3+(4*(n-1)))>) {
			animation: blinker 0.5s steps(1) <d> <(l+t+r)*2> normal forwards;
		}
		d += l+t+r
	*/

	secondsForLine := int(math.Round(float64(line.TypedLength) / charactersPerSecond))
	leftPadding := 0
	rightPadding := 0
	localPrefix := "\n" + shallowerIndent + ".typing-animator:nth-child("
	prefix := "\n" + shallowerIndent + localPrefix
	suffix := ";\n" + shallowerIndent + "}\n" + shallowerIndent
	debugSlowdown := 1 //1=off; >1=on

	if secondsForLine < 1 {
		secondsForLine = 1
	}

	switch line.RealNum {
	case 1:
		leftPadding = 1
		rightPadding = 1
		secondsForLine = 3
		prefix = " /*Autogenerated typing animation - see: github.com/GuzioMG/guziohub-generator for details*/\n" + shallowerIndent + "\n" + shallowerIndent + "body {" + "\n" + deeperIndent + "--content-length: " + fmt.Sprint(contentLength) + suffix + prefix
	case 2:
		leftPadding = 1
	case lastLine:
		rightPadding = 3
	}

	cssLine := prefix + fmt.Sprint(2+(4*(line.RealNum-1))) + ") {" + "\n" + deeperIndent + "animation: type " + fmt.Sprint(secondsForLine*debugSlowdown) + "s steps(" + fmt.Sprint(line.TypedLength) + ") " + fmt.Sprint((*cumulativeSeconds)+leftPadding) + "s 1 normal forwards" + suffix + localPrefix + fmt.Sprint(3+(4*(line.RealNum-1))) + ") {" + "\n" + deeperIndent + "animation: blinker 0.5s steps(1) " + fmt.Sprint(*cumulativeSeconds) + "s " + fmt.Sprint((leftPadding+secondsForLine+rightPadding)*2) + " normal forwards" + suffix
	*cumulativeSeconds += leftPadding + secondsForLine + rightPadding
	return cssLine
}

func Process(content *os.File, template TemplateData, to *os.File) error {

	// Loading content
	var contentText *string = nil
	meaningfulLines := 0
	if contentInfo, err := content.Stat(); err != nil {
		return err
	} else {
		contentBytes := make([]byte, contentInfo.Size())
		if len, err := content.Read(contentBytes); err != nil {
			return errors.Join(err, errors.New(("read \"" + fmt.Sprint(len) + "\" bytes from file \"" + content.Name() + "\" (contents of those bytes: ```html\n" + string(contentBytes) + "\n```), but then got the error above")))
		} else {
			contentContent := string(contentBytes)
			meaningfulLines = strings.Count(contentContent, "\n") - 2 // Less by 3 over real count to account for the opening, closing and DOCTYPE tags. Subtracting only 2 because Count counts the number of \n, which is always one less than the number of lines.
			if meaningfulLines <= 0 {
				return errors.New("file \"" + content.Name() + "\" does not appear to have any content (got \"" + fmt.Sprint(meaningfulLines) + "\" meaningful lines, ie. after discounting the opening, closing and DOCTYPE tags)")
			}
			contentText = &contentContent
		}
	}

	// Processing content
	parsedLines := make([]LineData, meaningfulLines)
	var extractedMetadata *DocumentData = nil
	maxTypedLength := 0
	overallWordCount := 0
	overallTypedLength := 0
	overallBytesLength := 0
	for index, line := range strings.Split(*contentText, "\n") {

		// Skip non-meaningful lines
		if index == 0 || index == 1 || index == meaningfulLines+2 {
			//...Unless they're invalid
			if index == 0 && !(strings.HasPrefix(line, "<!DOCTYPE ghtml-v1.") && strings.Contains(line, " \"") && strings.HasSuffix(line, "\">")) {
				return errors.New("file \"" + content.Name() + "\" does not appear to be a valid G-HTML v0 file (missing, wrong-versioned, or invalid DOCTYPE declaration - found \"" + line + "\" instead)")
			}

			if data, err := ExtractMetadata(line, content.Name()); index == 1 && err != nil {
				return err
			} else if index == 1 {
				extractedMetadata = data
			}

			if index == meaningfulLines+2 && line != "</html>" {
				return errors.New("file \"" + content.Name() + "\" does not appear to be a valid HTML file, of any (G-HTML, or otherwise) flavour (missing or invalid closing </html> tag - found \"" + line + "\" on line #" + fmt.Sprint(index+1) + " (the last one) instead)")
			}

			continue
		}

		// Process meaningful lines
		if processed, err := ProcessLine(line, "            ", content.Name(), index+1); err != nil {
			return err
		} else {
			parsedLines[index-2] = *processed
			maxTypedLength = int(math.Max(float64(maxTypedLength), float64(processed.TypedLength)))
			overallWordCount += processed.WordCount
			overallTypedLength += processed.TypedLengthWithoutSpaces
			overallBytesLength += processed.BytesLength
		}
	}

	// Combine parsed content lines; generate and combine CSS
	var parsedHTMLLinesCombined strings.Builder
	parsedHTMLLinesCombined.Grow(overallBytesLength)
	var parsedCSSLinesCombined strings.Builder
	wordsPerSecond := 300 / 60.0 // Average reading speed is 200-300 wpm and - considering how other parts of the animation  will slow down the average CPS, anyway - going with the higher end of that spectrum is needed to avoid boring users to death.
	charactersPerSecond := wordsPerSecond * (float64(overallTypedLength) / float64(overallWordCount))
	seconds := 0
	for _, line := range parsedLines {
		parsedHTMLLinesCombined.WriteString(line.ProcessedContent)
		parsedCSSLinesCombined.WriteString(BuildCSSLine(line, &seconds, charactersPerSecond, maxTypedLength, meaningfulLines, "            ", "                "))
	}

	// Write output
	toOutput := strings.ReplaceAll(*template.Content, "<p class=\"termtxt-warnings\">If you're reading this - something went very wrong. The page content is SUPPOSED to be here, but - clearly - it is not. Please file an issue at <a href=\"https://github.com/GuzioMG/guziohub\" class=\"termtxt-links custom-link-underlining\">https://github.com/GuzioMG/guziohub</a>.</p>", parsedHTMLLinesCombined.String())
	toOutput = strings.ReplaceAll(toOutput, " /*Slot for auto-generated CSS*/", parsedCSSLinesCombined.String())
	toOutput = strings.ReplaceAll(toOutput, "{{PAGE_LANG}}", extractedMetadata.Lang)
	toOutput = strings.ReplaceAll(toOutput, "{{CANONICAL_URL}}", extractedMetadata.Canonical)
	toOutput = strings.ReplaceAll(toOutput, "[PAGE TITLE - FILE AN ISSUE IF MISSING]", extractedMetadata.Title)
	toOutput = strings.ReplaceAll(toOutput, "<h1 class=\"termtxt-warnings\">If you're reading this - something went very wrong. The page title is SUPPOSED to be here, but - clearly - it is not. Please file an issue at <a href=\"https://github.com/GuzioMG/guziohub\" class=\"termtxt-links custom-link-underlining\">https://github.com/GuzioMG/guziohub</a>.</h1>", "<h1 class=\"termtxt-default\">"+extractedMetadata.Header+"</h1>")
	toOutput = strings.ReplaceAll(toOutput, "{{PAGE_DESCRIPTION}}", extractedMetadata.Description)
	if lenWr, err := to.Write([]byte(toOutput)); err != nil {
		return errors.Join(err, errors.New(("written \"" + fmt.Sprint(lenWr) + "\" bytes to file \"" + to.Name() + "\", but before the whole " + fmt.Sprint(len(([]byte(toOutput)))) + "-byte long content of ```html\n" + toOutput + "\n``` could be written, got the error above")))
	}

	return nil
}
